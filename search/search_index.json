{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Navycut - The Fullstack WebFramework \u00b6 Documentation: https://navycut.github.io Github Repo: https://github.com/flaskAio/navycut Overview \u00b6 With Navycut, you can take Web applications from concept to launch in a matter of hours. Navycut takes care of much of the hassle of Web development, so you can focus on writing your app without needing to reinvent the wheel. It\u2019s free and open source. It's fully created using The great microframework Flask and wsgi Werkzeug. It has all the flask battries included. Why Navycut \u00b6 Navycut provides the Flask based fullstack web development platform to create an interactive website instantly. Fullstack Support \u00b6 Navycut has the Flask based backend system as well as the Jinja2 Based template rendering system to design the frontend. Ridiculously Fast \u00b6 Navycut was designed to help developers take applications from concept to completion as quickly as possible. Fully Loaded \u00b6 Navycut includes dozens of extras you can use to handle common Web development tasks. Navycut takes care of user authentication, content administration, site maps, RSS feeds, and many more tasks \u2014 right out of the box. Reassuringly Secure \u00b6 Navycut takes security seriously and helps developers avoid many common security mistakes, such as SQL injection, cross-site scripting, cross-site request forgery and clickjacking. Its user authentication system provides a secure way to manage user accounts and passwords. Incredibly Versatile \u00b6 Companies, organizations and governments have used Django to build all sorts of things \u2014 from content management systems to social networks to scientific computing platforms.","title":"Navycut"},{"location":"#navycut-the-fullstack-webframework","text":"Documentation: https://navycut.github.io Github Repo: https://github.com/flaskAio/navycut","title":"Navycut - The Fullstack WebFramework"},{"location":"#overview","text":"With Navycut, you can take Web applications from concept to launch in a matter of hours. Navycut takes care of much of the hassle of Web development, so you can focus on writing your app without needing to reinvent the wheel. It\u2019s free and open source. It's fully created using The great microframework Flask and wsgi Werkzeug. It has all the flask battries included.","title":"Overview"},{"location":"#why-navycut","text":"Navycut provides the Flask based fullstack web development platform to create an interactive website instantly.","title":"Why Navycut"},{"location":"#fullstack-support","text":"Navycut has the Flask based backend system as well as the Jinja2 Based template rendering system to design the frontend.","title":"Fullstack Support"},{"location":"#ridiculously-fast","text":"Navycut was designed to help developers take applications from concept to completion as quickly as possible.","title":"Ridiculously Fast"},{"location":"#fully-loaded","text":"Navycut includes dozens of extras you can use to handle common Web development tasks. Navycut takes care of user authentication, content administration, site maps, RSS feeds, and many more tasks \u2014 right out of the box.","title":"Fully Loaded"},{"location":"#reassuringly-secure","text":"Navycut takes security seriously and helps developers avoid many common security mistakes, such as SQL injection, cross-site scripting, cross-site request forgery and clickjacking. Its user authentication system provides a secure way to manage user accounts and passwords.","title":"Reassuringly Secure"},{"location":"#incredibly-versatile","text":"Companies, organizations and governments have used Django to build all sorts of things \u2014 from content management systems to social networks to scientific computing platforms.","title":"Incredibly Versatile"},{"location":"installation/","text":"Installation \u00b6 Being a Python Web framework, Python requires Python. You must need to use Python version 3.6 or later. Python includes a lightweight database called SQLite so you won\u2019t need to set up a database just yet. Get the latest version of Python at https://www.python.org/downloads/ or with your operating system\u2019s package manager. You can verify that Python is installed by typing python from your shell; you should see something like: Python 3. x . y [ GCC 4. x ] on linux Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information . >>> Install navycut from pypi using pip: \u00b6 pip install -U navycut Install navycut from source code: \u00b6 git clone https://github.com/flaskAio/navycut.git cd navycut python setup.py install To verify that Navycut can be seen by Python, type python from your shell. Then at the Python prompt, try to import navycut: \u00b6 >>> import navycut >>> print ( navycut.get_version ()) 0 .0.4","title":"Installation"},{"location":"installation/#installation","text":"Being a Python Web framework, Python requires Python. You must need to use Python version 3.6 or later. Python includes a lightweight database called SQLite so you won\u2019t need to set up a database just yet. Get the latest version of Python at https://www.python.org/downloads/ or with your operating system\u2019s package manager. You can verify that Python is installed by typing python from your shell; you should see something like: Python 3. x . y [ GCC 4. x ] on linux Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information . >>>","title":"Installation"},{"location":"installation/#install-navycut-from-pypi-using-pip","text":"pip install -U navycut","title":"Install navycut from pypi using pip:"},{"location":"installation/#install-navycut-from-source-code","text":"git clone https://github.com/flaskAio/navycut.git cd navycut python setup.py install","title":"Install navycut from source code:"},{"location":"installation/#to-verify-that-navycut-can-be-seen-by-python-type-python-from-your-shell-then-at-the-python-prompt-try-to-import-navycut","text":">>> import navycut >>> print ( navycut.get_version ()) 0 .0.4","title":"To verify that Navycut can be seen by Python, type python from your shell. Then at the Python prompt, try to import navycut:"},{"location":"introduction/","text":"Intro to Navycut \u00b6 The basic introduction about the stack and features of Navyvut project. Object relational mapper \u00b6 De\ufb01ne your data models entirely in Python using SQLAlchemy. You get a rich, dynamic database-access API for free \u2014 but you can still write SQL if needed. from navycut.orm import sql class Band ( sql . Model ): \"\"\"A model of a rock band.\"\"\" id = sql . fields . Integer ( pk = True ) name = sql . fields . Char ( max_length = 200 ) can_rock = sql . fields . Boolean ( default = True ) class Member ( sql . Model ): \"\"\"A model of a rock band member.\"\"\" id = sql . fields . Integer ( pk = True ) name = sql . fields . Char ( help_text = \"Member's name\" , max_length = 200 ) instrument = sql . fields . Char ( choices = ( ( 'g' , \"Guitar\" ), ( 'b' , \"Bass\" ), ( 'd' , \"Drums\" ), ), max_length = 1 ) band = sql . fields . ForeignKey ( \"Band\" ) Urls and Views \u00b6 A clean, elegant URL scheme is an important detail in a high-quality Web application. Navycut encourages beautiful URL design and doesn\u2019t put any cruft in URLs, like .php or .asp. To design URLs for an application, you create a Python module called a URLconf. Like a table of contents for your app, it contains a simple mapping between URL patterns and your views. from navycut.urls import path , url , include from . import views \"\"\" The default url_prefix is the app name i.e \"/band\" for this case. If you want to change it and use your own customized name then plese update the url_prefix for a particular app on the sister.py file under the AppSister class. \"\"\" urlpatterns = [ path ( '/' , views . BandView , name = 'band-list' ), url ( '/<int:id>' , views . band_detail , name = 'band-detail' ), url ( '/search/?id=1' , views . band_search , name = 'band-search' ), include ( '/polls' , 'polls.urls' ) # include urlpatterns from another app ] from navycut.urls import MethodView from .models import Band class BandView ( MethodView ): def get ( self ): bands = Band . query . all () return self . render ( 'bands/band_listing.html' , { 'bands' : bands }) def band_details ( req , res , id ): band = Band . query . get ( id ) return res . json ( band ) def band_search ( req , res ): id = int ( req . args . get ( 'id' )) band = Band . query . get ( id ) return res . json ( band ) Templates \u00b6 Navycut's template language(Jinja2) is designed to strike a balance between power and ease. It\u2019s designed to feel comfortable and easy-to-learn to those used to working with HTML, like designers and front-end developers. But it is also flexible and highly extensible, allowing developers to augment the template language as needed. < html > < head > < title > Band Listing </ title > </ head > < body > < h1 > All Bands </ h1 > < ul > </ ul > </ body > Forms \u00b6 Navycut provides a powerful form library using wt-form that handles rendering forms as HTML, validating user-submitted data, and converting that data to native Python types. Navycut also provides a way to generate forms from your existing models and use those forms to create and update data. class RegistrationForm ( forms . Form ): username = forms . StringField ( 'Username' , [ forms . validators . Length ( min = 4 , max = 25 )]) email = forms . StringField ( 'Email Address' , [ forms . validators . Length ( min = 6 , max = 35 )]) password = forms . PasswordField ( 'New Password' , [ forms . validators . DataRequired (), forms . validators . EqualTo ( 'confirm' , message = 'Passwords must match' ) ]) confirm = forms . PasswordField ( 'Repeat Password' ) accept_tos = forms . BooleanField ( 'I accept the TOS' , [ forms . validators . DataRequired ()]) Authentication \u00b6 Navycut comes with a full-featured and secure authentication system. It handles user accounts, groups, permissions and cookie-based user sessions. This lets you easily build sites that allow users to create accounts and safely log in/out. from navycut.auth import login_required , current_user from navycut.http import JsonResponse from navycut.urls import MethodView class AuthView ( MethodView ): @login_required def get ( self ): return JsonResponse ( logged_in_username = current_user . username ) Admin Panel \u00b6 One of the most powerful parts of Navycut is its automatic admin interface. It reads metadata in your models to provide a powerful and production-ready interface that content producers can immediately use to start managing content on your site. It\u2019s easy to set up and provides many hooks for customization. Basically Navycut uses the default flask_admin module to provide this service. from navycut.admin import admin from navycut.admin.site.views import NCAdminModelView from .models import Band , Member class MemberAdminModelView ( NCAdminModelView ): \"\"\"Customize the look of the auto-generated admin for the Member model\"\"\" excluded_fields = [ 'name' ,] admin . register_model ( Band ) # Use the default options admin . register_model ( Member , MemberAdminModelView ) # Use the customized options Internationalization \u00b6 No service till now, need to develop. Security \u00b6 Navycut provides multiple protections against: Clickjacking Cross-site scripting Cross Site Request Forgery (CSRF) SQL injection Remote code execution","title":"Introduction"},{"location":"introduction/#intro-to-navycut","text":"The basic introduction about the stack and features of Navyvut project.","title":"Intro to Navycut"},{"location":"introduction/#object-relational-mapper","text":"De\ufb01ne your data models entirely in Python using SQLAlchemy. You get a rich, dynamic database-access API for free \u2014 but you can still write SQL if needed. from navycut.orm import sql class Band ( sql . Model ): \"\"\"A model of a rock band.\"\"\" id = sql . fields . Integer ( pk = True ) name = sql . fields . Char ( max_length = 200 ) can_rock = sql . fields . Boolean ( default = True ) class Member ( sql . Model ): \"\"\"A model of a rock band member.\"\"\" id = sql . fields . Integer ( pk = True ) name = sql . fields . Char ( help_text = \"Member's name\" , max_length = 200 ) instrument = sql . fields . Char ( choices = ( ( 'g' , \"Guitar\" ), ( 'b' , \"Bass\" ), ( 'd' , \"Drums\" ), ), max_length = 1 ) band = sql . fields . ForeignKey ( \"Band\" )","title":"Object relational mapper"},{"location":"introduction/#urls-and-views","text":"A clean, elegant URL scheme is an important detail in a high-quality Web application. Navycut encourages beautiful URL design and doesn\u2019t put any cruft in URLs, like .php or .asp. To design URLs for an application, you create a Python module called a URLconf. Like a table of contents for your app, it contains a simple mapping between URL patterns and your views. from navycut.urls import path , url , include from . import views \"\"\" The default url_prefix is the app name i.e \"/band\" for this case. If you want to change it and use your own customized name then plese update the url_prefix for a particular app on the sister.py file under the AppSister class. \"\"\" urlpatterns = [ path ( '/' , views . BandView , name = 'band-list' ), url ( '/<int:id>' , views . band_detail , name = 'band-detail' ), url ( '/search/?id=1' , views . band_search , name = 'band-search' ), include ( '/polls' , 'polls.urls' ) # include urlpatterns from another app ] from navycut.urls import MethodView from .models import Band class BandView ( MethodView ): def get ( self ): bands = Band . query . all () return self . render ( 'bands/band_listing.html' , { 'bands' : bands }) def band_details ( req , res , id ): band = Band . query . get ( id ) return res . json ( band ) def band_search ( req , res ): id = int ( req . args . get ( 'id' )) band = Band . query . get ( id ) return res . json ( band )","title":"Urls and Views"},{"location":"introduction/#templates","text":"Navycut's template language(Jinja2) is designed to strike a balance between power and ease. It\u2019s designed to feel comfortable and easy-to-learn to those used to working with HTML, like designers and front-end developers. But it is also flexible and highly extensible, allowing developers to augment the template language as needed. < html > < head > < title > Band Listing </ title > </ head > < body > < h1 > All Bands </ h1 > < ul > </ ul > </ body >","title":"Templates"},{"location":"introduction/#forms","text":"Navycut provides a powerful form library using wt-form that handles rendering forms as HTML, validating user-submitted data, and converting that data to native Python types. Navycut also provides a way to generate forms from your existing models and use those forms to create and update data. class RegistrationForm ( forms . Form ): username = forms . StringField ( 'Username' , [ forms . validators . Length ( min = 4 , max = 25 )]) email = forms . StringField ( 'Email Address' , [ forms . validators . Length ( min = 6 , max = 35 )]) password = forms . PasswordField ( 'New Password' , [ forms . validators . DataRequired (), forms . validators . EqualTo ( 'confirm' , message = 'Passwords must match' ) ]) confirm = forms . PasswordField ( 'Repeat Password' ) accept_tos = forms . BooleanField ( 'I accept the TOS' , [ forms . validators . DataRequired ()])","title":"Forms"},{"location":"introduction/#authentication","text":"Navycut comes with a full-featured and secure authentication system. It handles user accounts, groups, permissions and cookie-based user sessions. This lets you easily build sites that allow users to create accounts and safely log in/out. from navycut.auth import login_required , current_user from navycut.http import JsonResponse from navycut.urls import MethodView class AuthView ( MethodView ): @login_required def get ( self ): return JsonResponse ( logged_in_username = current_user . username )","title":"Authentication"},{"location":"introduction/#admin-panel","text":"One of the most powerful parts of Navycut is its automatic admin interface. It reads metadata in your models to provide a powerful and production-ready interface that content producers can immediately use to start managing content on your site. It\u2019s easy to set up and provides many hooks for customization. Basically Navycut uses the default flask_admin module to provide this service. from navycut.admin import admin from navycut.admin.site.views import NCAdminModelView from .models import Band , Member class MemberAdminModelView ( NCAdminModelView ): \"\"\"Customize the look of the auto-generated admin for the Member model\"\"\" excluded_fields = [ 'name' ,] admin . register_model ( Band ) # Use the default options admin . register_model ( Member , MemberAdminModelView ) # Use the customized options","title":"Admin Panel"},{"location":"introduction/#internationalization","text":"No service till now, need to develop.","title":"Internationalization"},{"location":"introduction/#security","text":"Navycut provides multiple protections against: Clickjacking Cross-site scripting Cross Site Request Forgery (CSRF) SQL injection Remote code execution","title":"Security"},{"location":"documentation/","text":"Basic Documentation \u00b6 Everything you need to know about Navycut. The documentation part for the Navycut framework is defined by all of the available layers. Here we have tried to explain all of the layers of navycut for the better understanding. How the documentation is organized \u00b6 Navycut has a lot of documentation. A high-level overview of how it\u2019s organized will help you know where to look for certain things: Tutorials take you by the hand through a series of steps to create a Web application. Start here if you\u2019re new to Navycut or Web application development. Also look at the \u201cFirst steps\u201d. Topic guides discuss key topics and concepts at a fairly high level and provide useful background information and explanation. Reference guides contain technical reference for APIs and other aspects of Navycut machinery. They describe how it works and how to use it but assume that you have a basic understanding of key concepts. How-to guides are recipes. They guide you through the steps involved in addressing key problems and use-cases. They are more advanced than tutorials and assume some knowledge of how Navycut works. The Model Layer : \u00b6 Django provides an abstraction layer (the \u201cmodels\u201d) for structuring and manipulating the data of your Web application. Learn more about it below:","title":"Basic Documentation"},{"location":"documentation/#basic-documentation","text":"Everything you need to know about Navycut. The documentation part for the Navycut framework is defined by all of the available layers. Here we have tried to explain all of the layers of navycut for the better understanding.","title":"Basic Documentation"},{"location":"documentation/#how-the-documentation-is-organized","text":"Navycut has a lot of documentation. A high-level overview of how it\u2019s organized will help you know where to look for certain things: Tutorials take you by the hand through a series of steps to create a Web application. Start here if you\u2019re new to Navycut or Web application development. Also look at the \u201cFirst steps\u201d. Topic guides discuss key topics and concepts at a fairly high level and provide useful background information and explanation. Reference guides contain technical reference for APIs and other aspects of Navycut machinery. They describe how it works and how to use it but assume that you have a basic understanding of key concepts. How-to guides are recipes. They guide you through the steps involved in addressing key problems and use-cases. They are more advanced than tutorials and assume some knowledge of how Navycut works.","title":"How the documentation is organized"},{"location":"documentation/#the-model-layer","text":"Django provides an abstraction layer (the \u201cmodels\u201d) for structuring and manipulating the data of your Web application. Learn more about it below:","title":"The Model Layer:"},{"location":"documentation/common-web-application-tools/","text":"","title":"Common web application tools"},{"location":"documentation/development-process/","text":"","title":"Development process"},{"location":"documentation/forms/","text":"","title":"Forms"},{"location":"documentation/internationalization-and-localization/","text":"","title":"Internationalization and localization"},{"location":"documentation/model-layer/","text":"Introduction \u00b6 A model is the single, definitive source of information about your data. It contains the essential fields and behaviors of the data you\u2019re storing. Generally, each model maps to a single database table. Here by default we are using Flask-SQLAlchemy ORM for model layer. The basics: Each model is a Python class that subclasses navycut.orm.sqla.sql.Model. Each attribute of the model represents a database field. With all of this, Navycut gives you an automatically-generated database-access API. Quick Example \u00b6 This example model defines a Person, which has a first_name and last_name: from navycut.orm import sql class Person ( models . Model ): first_name = sql . fields . Char ( max_length = 30 ) last_name = sql . fields . Char ( max_length = 30 ) first_name and last_name are fields of the model. Each field is specified as a class attribute, and each attribute maps to a database column. The above Person model would create a database table like this: CREATE TABLE person ( \"id\" serial NOT NULL PRIMARY KEY , \"first_name\" varchar ( 30 ) NOT NULL , \"last_name\" varchar ( 30 ) NOT NULL ); Using Models \u00b6 Once you have defined your models, you need to tell Navycut you\u2019re going to use those models. Do this by editing your settings file and changing the INSTALLED_APPS setting to add the name of the module that contains your models.py. For example, if the models for your application live in the module myapp.models (the package structure that is created for an application by the manage.py createapp script), INSTALLED_APPS should read, in part: INSTALLED_APPS = [ #... 'myapp' , #... When you add new apps to INSTALLED_APPS , be sure to run manage.py migrate , optionally making migrations for them first with manage.py makemigrations . Fields \u00b6 The most important part of a model \u2013 and the only required part of a model \u2013 is the list of database fields it defines. Fields are specified by class attributes. Be careful not to choose field names that conflict with the models API like clean , save , or delete . Here we are using the sqlalchemy default fields and added some more custom fields like ImageField or JsonField . field_class : navycut.orm.sqla.fields.Fields Example from navycut.orm import sql from datetime import datetime class Blog ( sql . Model ): id = sql . fields . Integer ( pk = True ) title = sql . fields . Char ( max_length = 50 ) body = sql . fields . Text ( required = True ) image = sql . fields . Image ( required = True ) created_at = sql . fields . DateTime ( default = datetime . now ) author_ptr_id = sql . fields . ForeignKey ( \"Author\" ) class Author ( sql . Model ): id = sql . fields . Integer ( pk = True ) name = sql . fields . Char ( max_length = 100 , required = True ) image = sql . fields . Image ( required = True ) blog = sql . fields . OneToMany ( \"Blog\" ) Field Types \u00b6 Each field in your model should be an instance of the appropriate Field class. Navycut uses the field class types to determine a few things: The column type, which tells the database what kind of data to store (e.g. INTEGER, VARCHAR, TEXT ). The default HTML widget to use when rendering a form field (e.g. <input type=\"text\">, <select> ). The minimal validation requirements, used in Navycut\u2019s admin and in automatically-generated forms. Navycut ships with dozens of built-in field types. Internally it's using SQLAlchemy module to deliver the services and apis. Char \u00b6 method => Fields.Char(max_length:int=255, required:bool=False, pk:bool=False, unique:bool=False, choices:tuple=None,help_text:str=None) A string field, for small- to large-sized strings. For large amounts of text, use TextField. Text \u00b6 method => Fields.Text(required:bool=False, unique:bool=False, help_text:str=None, widget:str=\"ckeditor\") - wdiget: Declare the text widget are box for admin section. Default is \"ckeditor\". available options - \"ckeditor\", \"tinymce\" Float \u00b6 method => Fields.Float(required:bool=False, unique:bool=False, pk:bool=False,choices:tuple=None,help_text:str=None) The Float fields for sqlalchemy, Integer \u00b6 method => Fields.Integer(required:bool=False, unique:bool=False, pk:bool=False,choices:tuple=None,help_text:str=None) BigInteger \u00b6 method => Fields.BigInteger(required:bool=False, unique:bool=False, pk:bool=False,choices:tuple=None,help_text:str=None) SmallInteger \u00b6 method => Fields.SmallInteger(required:bool=False, unique:bool=False, pk:bool=False,choices:tuple=None,help_text:str=None) Boolean \u00b6 method => Fields.Boolean(required:bool=False, unique:bool=False, default:bool=False, help_text:str=None) Json \u00b6 method => Fields.Json(required:bool=False, default={}, help_text:str=None) Image \u00b6 method => Fields.Image(required:bool=False, help_text:str=None) Binary \u00b6 method => Fields.Binary(required:bool=False, default=None, help_text:str=None) LargeBinary \u00b6 method => Fields.LargeBinary(required:bool=False, default=None, help_text:str=None) Time \u00b6 method => Fields.Time(required:bool=False, default=None, help_text:str=None, choices:tuple=None) Date \u00b6 method => Fields.Date(required:bool=False, default=None, help_text:str=None, choices:tuple=None) DateTime \u00b6 method => Fields.DateTime(required:bool=False, default=None, help_text:str=None, choices:tuple=None) ForiegnKey \u00b6 method => Fields.ForiegnKey(model:str,unique:bool=False,required:bool=False,help_text:str=None) OneToOne \u00b6 method => Fields.OneToOne(model:str, backref:str, uselist:bool = False,) ManyToOne \u00b6 method => Fields.ManyToOne(model:str, backref:str, uselist:bool = False,) Field Options \u00b6 Each field takes a certain set of field-specific arguments (documented in the model field reference). For example, CharField (and its subclasses) require a max_length argument which specifies the size of the VARCHAR database field used to store the data. There\u2019s also a set of common arguments available to all field types. All are optional. They\u2019re fully explained in the reference, but here\u2019s a quick summary of the most often-used ones: max_length The maximum length of the field. only applicable for Cahr field. Default value is 255. required If False, the field is allowed to be blank. Default is False. pk If True, this field is the primary key for the model. unique If True, this field must be unique throughout the table. help_text Extra help text to be displayed with the form widget. It\u2019s useful for documentation even if your field isn\u2019t used on a form. choices A sequence consisting itself of iterables of exactly two items (e.g. [(A, B), (A, B) ...]) to use as choices for this field. If choices are given, they\u2019re enforced by model validation and the default form widget will be a select box with these choices instead of the standard text field. A choice list should look like this: YEAR_IN_SCHOOL_CHOICES = [ ( 'FR' , 'Freshman' ), ( 'SO' , 'Sophomore' ), ( 'JR' , 'Junior' ), ( 'SR' , 'Senior' ), ( 'GR' , 'Graduate' ), ] The first element in each tuple is the value that will be stored in the database. The second element is displayed by the field\u2019s form widget. Given a model instance, the display value for a field with choices can be accessed using the get_FOO_display() method. For example: from navycut.orm import sql class Person ( sql . Model ): SHIRT_SIZES = ( ( 'S' , 'Small' ), ( 'M' , 'Medium' ), ( 'L' , 'Large' ), ) name = sql . fields . Char ( max_length = 60 ) shirt_size = sql . fields . Char ( max_length = 1 , choices = SHIRT_SIZES ) >>> p = Person ( name = \"Fred Flintstone\" , shirt_size = \"L\" ) >>> p . save () >>> p . shirt_size 'L' >>> p . get_shirt_size_display () 'Large' Automatic primary key fields \u00b6 By default, Navycut gives each model an auto-incrementing primary key with the type specified per app. For example: id = sql . fields . Integer ( pk = True ) If you\u2019d like to specify a custom primary key, specify pk=True on one of your fields. Relationships \u00b6 Clearly, the power of relational databases lies in relating tables to each other. Navycut offers ways to define the three most common types of database relationships: many-to-one, many-to-many and one-to-one. Many-to-one relationships \u00b6 To define a many-to-one relationship, use Navycut.orm.sqla.fields.Fields.ManyToOne You use it just like any other Field type: by including it as a class attribute of your model also you need to add a Navycut.orm.sqla.fields.Fields.ForiegnKey filed with the connectable model class. For example, if a Blog model has a Author \u2013 that is, a Author makes multiple blogs but each Blog only has one Author \u2013 use the following definitions: from navycut.orm.sqla import sql class Blog ( sql . Model ): id = sql . fields . Integer ( pk = True , unique = True ) heading = sql . fields . Char ( required = True , unique = True ) author = sql . fields . ManyToOne ( \"Author\" ) class Author ( sql . Model ): id = sql . fields . Integer ( pk = True , unique = True ) name = sql . fields . Char ( required = True , unique = True ) blog_id = sql . fields . ForiegnKey ( \"Blog\" ) One-to-one relationship \u00b6 To define the OneToOne relationship please use Navycut.orm.sqla.fields.Fields.OneToOne and don't forgot to use Navycut.orm.sqla.fields.Fields.ForiegnKey because it's required for every kind of relation. For example, Here we have added two models one is Blog and another one is Author. Now the desired relation is one author can publish only one blog post. Check the below example to check the implementation procedure. from navycut.orm.sqla import sql class Blog ( sql . Model ): id = sql . fields . Integer ( pk = True , unique = True ) heading = sql . fields . Char ( required = True , unique = True ) author = sql . fields . OneToOne ( \"Author\" ) class Author ( sql . Model ): id = sql . fields . Integer ( pk = True , unique = True ) name = sql . fields . Char ( required = True , unique = True ) blog_id = sql . fields . ForiegnKey ( \"Blog\" , unique = True ) Many-to-many relationship \u00b6 Curently we don't have any special method tod define the many-to-manu relationship. You can use the default SQLAlchemy process to implement the Many-to-many relationship. Making Queries \u00b6 Once you\u2019ve created your data models, Navycut automatically gives you a database-abstraction API that lets you create, retrieve, update and delete objects. Since it's using SQLAlchemy module so the queries APIs are same with it. We are contiously trying to develop some more features and APIs for the query section. Please be in touch for the latest code update. For original documentation of SQLAlchemy quries please click here Create a new object \u00b6 Please check teh below example to learn more about the data creation procedure of Navycut framework: >>> from blog.models import Blog >>> b = Blog ( name = 'Beatles Blog' , tagline = 'All the latest Beatles news.' ) >>> b . save () Delete a Object \u00b6 >>> from blog.models import Blog >>> b = Blog . query . get ( 1 ) >>> b . delete () Migration \u00b6 Migrations are Navycut\u2019s way of propagating changes you make to your models (adding a field, deleting a model, etc.) into your database schema. They\u2019re designed to be mostly automatic, but you\u2019ll need to know when to make migrations, when to run them, and the common problems you might run into. Navycut is using flask-migrate module to deliver this service. The Commands \u00b6 There are several commands which you will use to interact with migrations and Navycut\u2019s handling of database schema: migrate , which is responsible for applying and unapplying migrations. makemigrations , which is responsible for creating new migrations based on the changes you have made to your models. sqlmigrate , which displays the SQL statements for a migration. You should think of migrations as a version control system for your database schema. makemigrations is responsible for packaging up your model changes into individual migration files - analogous to commits - and migrate is responsible for applying those to your database.","title":"Model layer"},{"location":"documentation/model-layer/#introduction","text":"A model is the single, definitive source of information about your data. It contains the essential fields and behaviors of the data you\u2019re storing. Generally, each model maps to a single database table. Here by default we are using Flask-SQLAlchemy ORM for model layer. The basics: Each model is a Python class that subclasses navycut.orm.sqla.sql.Model. Each attribute of the model represents a database field. With all of this, Navycut gives you an automatically-generated database-access API.","title":"Introduction"},{"location":"documentation/model-layer/#quick-example","text":"This example model defines a Person, which has a first_name and last_name: from navycut.orm import sql class Person ( models . Model ): first_name = sql . fields . Char ( max_length = 30 ) last_name = sql . fields . Char ( max_length = 30 ) first_name and last_name are fields of the model. Each field is specified as a class attribute, and each attribute maps to a database column. The above Person model would create a database table like this: CREATE TABLE person ( \"id\" serial NOT NULL PRIMARY KEY , \"first_name\" varchar ( 30 ) NOT NULL , \"last_name\" varchar ( 30 ) NOT NULL );","title":"Quick Example"},{"location":"documentation/model-layer/#using-models","text":"Once you have defined your models, you need to tell Navycut you\u2019re going to use those models. Do this by editing your settings file and changing the INSTALLED_APPS setting to add the name of the module that contains your models.py. For example, if the models for your application live in the module myapp.models (the package structure that is created for an application by the manage.py createapp script), INSTALLED_APPS should read, in part: INSTALLED_APPS = [ #... 'myapp' , #... When you add new apps to INSTALLED_APPS , be sure to run manage.py migrate , optionally making migrations for them first with manage.py makemigrations .","title":"Using Models"},{"location":"documentation/model-layer/#fields","text":"The most important part of a model \u2013 and the only required part of a model \u2013 is the list of database fields it defines. Fields are specified by class attributes. Be careful not to choose field names that conflict with the models API like clean , save , or delete . Here we are using the sqlalchemy default fields and added some more custom fields like ImageField or JsonField . field_class : navycut.orm.sqla.fields.Fields Example from navycut.orm import sql from datetime import datetime class Blog ( sql . Model ): id = sql . fields . Integer ( pk = True ) title = sql . fields . Char ( max_length = 50 ) body = sql . fields . Text ( required = True ) image = sql . fields . Image ( required = True ) created_at = sql . fields . DateTime ( default = datetime . now ) author_ptr_id = sql . fields . ForeignKey ( \"Author\" ) class Author ( sql . Model ): id = sql . fields . Integer ( pk = True ) name = sql . fields . Char ( max_length = 100 , required = True ) image = sql . fields . Image ( required = True ) blog = sql . fields . OneToMany ( \"Blog\" )","title":"Fields"},{"location":"documentation/model-layer/#field-types","text":"Each field in your model should be an instance of the appropriate Field class. Navycut uses the field class types to determine a few things: The column type, which tells the database what kind of data to store (e.g. INTEGER, VARCHAR, TEXT ). The default HTML widget to use when rendering a form field (e.g. <input type=\"text\">, <select> ). The minimal validation requirements, used in Navycut\u2019s admin and in automatically-generated forms. Navycut ships with dozens of built-in field types. Internally it's using SQLAlchemy module to deliver the services and apis.","title":"Field Types"},{"location":"documentation/model-layer/#char","text":"method => Fields.Char(max_length:int=255, required:bool=False, pk:bool=False, unique:bool=False, choices:tuple=None,help_text:str=None) A string field, for small- to large-sized strings. For large amounts of text, use TextField.","title":"Char"},{"location":"documentation/model-layer/#text","text":"method => Fields.Text(required:bool=False, unique:bool=False, help_text:str=None, widget:str=\"ckeditor\") - wdiget: Declare the text widget are box for admin section. Default is \"ckeditor\". available options - \"ckeditor\", \"tinymce\"","title":"Text"},{"location":"documentation/model-layer/#float","text":"method => Fields.Float(required:bool=False, unique:bool=False, pk:bool=False,choices:tuple=None,help_text:str=None) The Float fields for sqlalchemy,","title":"Float"},{"location":"documentation/model-layer/#integer","text":"method => Fields.Integer(required:bool=False, unique:bool=False, pk:bool=False,choices:tuple=None,help_text:str=None)","title":"Integer"},{"location":"documentation/model-layer/#biginteger","text":"method => Fields.BigInteger(required:bool=False, unique:bool=False, pk:bool=False,choices:tuple=None,help_text:str=None)","title":"BigInteger"},{"location":"documentation/model-layer/#smallinteger","text":"method => Fields.SmallInteger(required:bool=False, unique:bool=False, pk:bool=False,choices:tuple=None,help_text:str=None)","title":"SmallInteger"},{"location":"documentation/model-layer/#boolean","text":"method => Fields.Boolean(required:bool=False, unique:bool=False, default:bool=False, help_text:str=None)","title":"Boolean"},{"location":"documentation/model-layer/#json","text":"method => Fields.Json(required:bool=False, default={}, help_text:str=None)","title":"Json"},{"location":"documentation/model-layer/#image","text":"method => Fields.Image(required:bool=False, help_text:str=None)","title":"Image"},{"location":"documentation/model-layer/#binary","text":"method => Fields.Binary(required:bool=False, default=None, help_text:str=None)","title":"Binary"},{"location":"documentation/model-layer/#largebinary","text":"method => Fields.LargeBinary(required:bool=False, default=None, help_text:str=None)","title":"LargeBinary"},{"location":"documentation/model-layer/#time","text":"method => Fields.Time(required:bool=False, default=None, help_text:str=None, choices:tuple=None)","title":"Time"},{"location":"documentation/model-layer/#date","text":"method => Fields.Date(required:bool=False, default=None, help_text:str=None, choices:tuple=None)","title":"Date"},{"location":"documentation/model-layer/#datetime","text":"method => Fields.DateTime(required:bool=False, default=None, help_text:str=None, choices:tuple=None)","title":"DateTime"},{"location":"documentation/model-layer/#foriegnkey","text":"method => Fields.ForiegnKey(model:str,unique:bool=False,required:bool=False,help_text:str=None)","title":"ForiegnKey"},{"location":"documentation/model-layer/#onetoone","text":"method => Fields.OneToOne(model:str, backref:str, uselist:bool = False,)","title":"OneToOne"},{"location":"documentation/model-layer/#manytoone","text":"method => Fields.ManyToOne(model:str, backref:str, uselist:bool = False,)","title":"ManyToOne"},{"location":"documentation/model-layer/#field-options","text":"Each field takes a certain set of field-specific arguments (documented in the model field reference). For example, CharField (and its subclasses) require a max_length argument which specifies the size of the VARCHAR database field used to store the data. There\u2019s also a set of common arguments available to all field types. All are optional. They\u2019re fully explained in the reference, but here\u2019s a quick summary of the most often-used ones: max_length The maximum length of the field. only applicable for Cahr field. Default value is 255. required If False, the field is allowed to be blank. Default is False. pk If True, this field is the primary key for the model. unique If True, this field must be unique throughout the table. help_text Extra help text to be displayed with the form widget. It\u2019s useful for documentation even if your field isn\u2019t used on a form. choices A sequence consisting itself of iterables of exactly two items (e.g. [(A, B), (A, B) ...]) to use as choices for this field. If choices are given, they\u2019re enforced by model validation and the default form widget will be a select box with these choices instead of the standard text field. A choice list should look like this: YEAR_IN_SCHOOL_CHOICES = [ ( 'FR' , 'Freshman' ), ( 'SO' , 'Sophomore' ), ( 'JR' , 'Junior' ), ( 'SR' , 'Senior' ), ( 'GR' , 'Graduate' ), ] The first element in each tuple is the value that will be stored in the database. The second element is displayed by the field\u2019s form widget. Given a model instance, the display value for a field with choices can be accessed using the get_FOO_display() method. For example: from navycut.orm import sql class Person ( sql . Model ): SHIRT_SIZES = ( ( 'S' , 'Small' ), ( 'M' , 'Medium' ), ( 'L' , 'Large' ), ) name = sql . fields . Char ( max_length = 60 ) shirt_size = sql . fields . Char ( max_length = 1 , choices = SHIRT_SIZES ) >>> p = Person ( name = \"Fred Flintstone\" , shirt_size = \"L\" ) >>> p . save () >>> p . shirt_size 'L' >>> p . get_shirt_size_display () 'Large'","title":"Field Options"},{"location":"documentation/model-layer/#automatic-primary-key-fields","text":"By default, Navycut gives each model an auto-incrementing primary key with the type specified per app. For example: id = sql . fields . Integer ( pk = True ) If you\u2019d like to specify a custom primary key, specify pk=True on one of your fields.","title":"Automatic primary key fields"},{"location":"documentation/model-layer/#relationships","text":"Clearly, the power of relational databases lies in relating tables to each other. Navycut offers ways to define the three most common types of database relationships: many-to-one, many-to-many and one-to-one.","title":"Relationships"},{"location":"documentation/model-layer/#many-to-one-relationships","text":"To define a many-to-one relationship, use Navycut.orm.sqla.fields.Fields.ManyToOne You use it just like any other Field type: by including it as a class attribute of your model also you need to add a Navycut.orm.sqla.fields.Fields.ForiegnKey filed with the connectable model class. For example, if a Blog model has a Author \u2013 that is, a Author makes multiple blogs but each Blog only has one Author \u2013 use the following definitions: from navycut.orm.sqla import sql class Blog ( sql . Model ): id = sql . fields . Integer ( pk = True , unique = True ) heading = sql . fields . Char ( required = True , unique = True ) author = sql . fields . ManyToOne ( \"Author\" ) class Author ( sql . Model ): id = sql . fields . Integer ( pk = True , unique = True ) name = sql . fields . Char ( required = True , unique = True ) blog_id = sql . fields . ForiegnKey ( \"Blog\" )","title":"Many-to-one relationships"},{"location":"documentation/model-layer/#one-to-one-relationship","text":"To define the OneToOne relationship please use Navycut.orm.sqla.fields.Fields.OneToOne and don't forgot to use Navycut.orm.sqla.fields.Fields.ForiegnKey because it's required for every kind of relation. For example, Here we have added two models one is Blog and another one is Author. Now the desired relation is one author can publish only one blog post. Check the below example to check the implementation procedure. from navycut.orm.sqla import sql class Blog ( sql . Model ): id = sql . fields . Integer ( pk = True , unique = True ) heading = sql . fields . Char ( required = True , unique = True ) author = sql . fields . OneToOne ( \"Author\" ) class Author ( sql . Model ): id = sql . fields . Integer ( pk = True , unique = True ) name = sql . fields . Char ( required = True , unique = True ) blog_id = sql . fields . ForiegnKey ( \"Blog\" , unique = True )","title":"One-to-one relationship"},{"location":"documentation/model-layer/#many-to-many-relationship","text":"Curently we don't have any special method tod define the many-to-manu relationship. You can use the default SQLAlchemy process to implement the Many-to-many relationship.","title":"Many-to-many relationship"},{"location":"documentation/model-layer/#making-queries","text":"Once you\u2019ve created your data models, Navycut automatically gives you a database-abstraction API that lets you create, retrieve, update and delete objects. Since it's using SQLAlchemy module so the queries APIs are same with it. We are contiously trying to develop some more features and APIs for the query section. Please be in touch for the latest code update. For original documentation of SQLAlchemy quries please click here","title":"Making Queries"},{"location":"documentation/model-layer/#create-a-new-object","text":"Please check teh below example to learn more about the data creation procedure of Navycut framework: >>> from blog.models import Blog >>> b = Blog ( name = 'Beatles Blog' , tagline = 'All the latest Beatles news.' ) >>> b . save ()","title":"Create a new object"},{"location":"documentation/model-layer/#delete-a-object","text":">>> from blog.models import Blog >>> b = Blog . query . get ( 1 ) >>> b . delete ()","title":"Delete a Object"},{"location":"documentation/model-layer/#migration","text":"Migrations are Navycut\u2019s way of propagating changes you make to your models (adding a field, deleting a model, etc.) into your database schema. They\u2019re designed to be mostly automatic, but you\u2019ll need to know when to make migrations, when to run them, and the common problems you might run into. Navycut is using flask-migrate module to deliver this service.","title":"Migration"},{"location":"documentation/model-layer/#the-commands","text":"There are several commands which you will use to interact with migrations and Navycut\u2019s handling of database schema: migrate , which is responsible for applying and unapplying migrations. makemigrations , which is responsible for creating new migrations based on the changes you have made to your models. sqlmigrate , which displays the SQL statements for a migration. You should think of migrations as a version control system for your database schema. makemigrations is responsible for packaging up your model changes into individual migration files - analogous to commits - and migrate is responsible for applying those to your database.","title":"The Commands"},{"location":"documentation/other-core-functionalities/","text":"","title":"Other core functionalities"},{"location":"documentation/performance-and-optimization/","text":"","title":"Performance and optimization"},{"location":"documentation/security/","text":"","title":"Security"},{"location":"documentation/template-layer/","text":"","title":"Template layer"},{"location":"documentation/the-admin/","text":"","title":"The admin"},{"location":"documentation/view-layer/","text":"","title":"View layer"}]}